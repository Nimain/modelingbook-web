<html>

<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <title>Interactive Models</title>
	<link href="favicon.png" rel="shortcut icon">
	<link href="style.css" type="text/css" rel="stylesheet">
	<link href="jsxgraph.css" type="text/css" rel="stylesheet">
	<script src="libraries/jsxgraphcore.js" type="text/javascript"></script>
</head>

<body>
	<div id="preview">
		<section id="content">
			<article class="measure">
				<header>
					
					<h1><span id="visual">Interactive</span> <span id="math">Models</span></h1>
					
				</header>
				
				<h2>Hysteresis</h2>
				
				<p>Gridlover keeps sizing type tidy and logical.
				    Font sizes are calculated by stepping up the font size by the scale factor.
				    For a detailed explanation, see <a href="http://www.alistapart.com/articles/more-meaningful-typography/">More Meaningful Typography</a> at A List Apart.
				    Elements in Gridlover are always kept aligned to a baseline grid. Here's another article to read, <a href="http://www.alistapart.com/articles/settingtypeontheweb">Setting Type on the Web to a Baseline Grid</a>.
				</p>
				<div class="examplespace">
					<div class="jsxbox" id="examplespace" style="height:500px;">
				</div>
				<script type="text/javascript">
					JXG.Options = JXG.deepCopy(JXG.Options, {
					    showNavigation: false,
						showCopyright: false,
					}
					);
					var brd = JXG.JSXGraph.initBoard('examplespace', {axis:true, boundingbox:[-11,11,11,-11]});
					var N = brd.create('slider',[[-7,10.5],[7,10.5],[-15,10,15]], {name:'N'});
					var P = brd.create('point',[0,1], {name:'(x_0,y_0)'});
					
					function doIt() {
					  f = new Function("x", "yy", "var y = yy[0]; var z = (2-x)*y; return [z]");
					  brd.update();
					}

					function ode() {
					   return JXG.Math.Numerics.rungeKutta('heun', [P.Y()], [P.X(), P.X()+N.Value()], 200, f);
					}

					var g = brd.create('curve', [[0],[0]], {strokeColor:'red', strokeWidth:'2px'});
					g.updateDataArray = function() {
					    var data = ode();
					    var h = N.Value()/200;
					    this.dataX = [];
					    this.dataY = [];
					    for(var i=0; i<data.length; i++) {
					        this.dataX[i] = P.X()+i*h;
					        this.dataY[i] = data[i][0];
					    }
					};
					doIt();
				</script>
			</article>
		</section>
	</div>
</body></html>